import Data.Ratio
import Control.Monad (guard)

import Math.GenBase.Recur
import Math.GenBase.Base
import Math.Sequence.Sequence
import Math.Sequence.Natrep

floatRound = 1e-10

palindrome = (==) <*> reverse

--safe rounding for almost-integers
close :: (RealFrac a, Integral b) => a -> a -> Maybe b
close r x = do let x' = round x
               guard $ (<r) $ abs $ x - fromIntegral x'
               return x'

--calculate the exact root for a Lucas recurrence
--the Left value is for rational roots
--the Right value is for irrational roots: the rational part, 
--  the irrational part, and the denominator
exactRoot :: Lucas -> Either (Rational, Rational) (Int, Int, Int)
exactRoot (Lucas p q) = do let discr  = p^2 + 4*q
                           let discr' = close floatRound $ sqrt $ fromIntegral discr
                           let trydiv x = Left (fromIntegral (p + x) % 2, fromIntegral (p - x) % 2)
                           a <- maybe (Right discr) trydiv discr'
                           --discr mod 4 = 0 implies that p^2 is even, which implies p is even
                           let result | a `mod` 4 == 0 = (p `div` 2, a `div` 4, 1)
                                      | otherwise      = (p, a, 2)
                           return result

binary  = count (Normal 2)
phinary = count (Nnacci 2)
fibBin  = frombasei (Nnacci 2)
fibs    = linseq (Nnacci 2)

trinary = count (Nnacci 3)
tribs   = linseq (Nnacci 3)

--numbers whose base phi representation is palindromic (A330722)
phiPalin = phinary `satisfying` (palindrome . fVect)
--numbers whose base phi representation is palindromic about the decimal point (A330672)
phiPalinStrong = phinary `satisfying` (\(Fp a b) -> palindrome a && even b)
--binary palindromes
binPalin = binary `satisfying` (palindrome . fVect)

--A133457
binZeros = binary >>= nonZeroPos . map fromIntegral . reverse . fVect
--positions of nonzero elements of phinary numbers, concatted together
phiZeros = phinary >>= nonZeroPos . map fromIntegral . reverse . fVect

hamming  = map (sum . fVect) binary
--hamming weight of phinary strings (A055778)
phihamming = map (sum . fVect) phinary
--length of phinary strings
philen = map (length . fVect) phinary

--generalized version of A105425 for n-nacci constants
--in the limit as n -> oo, the recurrence just becomes a representation of binary, and
--all numbers are included
genfibinary = map (frombasei (2 :: Integer)) . seqcount . Nnacci

--the numbers generated by a particular recurrence seem to be the position of
--0's in a beatty sequence
--numbers for which the integral part of the expansion is
--is not a generalized zeckendorf expansion
recurSkip a = missing' nary countdorf'
  where nary       = map integ $ count a     --strings of integral parts of this base
        countdorf' = zip [0..] $ seqcount a --strings of recurrence relation expansion
        missing' (x:xs) ys@((y,yy):yys) | x /= yy   = y:(missing' xs ys)
                                        | otherwise = missing' xs yys

--the dual of the above: numbers for which the generalized zeckendorf expansion
--is not the integral part of a polynomial expansion
--equivalent to \a -> (count a) `lost` (frombasei a . map fromIntegral . integ)
recurSkipDual a = missing' nary countdorf'
  where nary       = map integ $ count a
        countdorf' = zip [0..] $ seqcount a
        missing' xs@(x:xxs) ((y,yy):yys) | x /= yy   = y:(missing' xs yys)
                                         | otherwise = missing' xxs yys

--A sampling of results:
--A188039
--recurSkip $ Lucas 2 1
--A284853
--recurSkip $ Lucas 2 2

--one more than the wythoff BB numbers (?) (A101864(n) + 1)
--numbers whose zeckendorf expansions are never formed by the integral part of a base phi number
--phinary `lost` (fibBin . map fromIntegral . integ)
--recurskipDual $ Nnacci 2

--appears to be a cycle of n 0's, followed by two 1's
--these correspond to the parity of a recurrence of (n 1's, followed by n)
parities n = map (`mod` 2) $ linseq $ Literal $ replicate n 1 ++ [n]

--unnamedRoot n = phi, 2, ... -> 2 (yes, geometric)
unnamedRoot n = (root 1e-10) . Literal $ replicate n 1 ++ [n]

--first difference of length 1 for the first term, 2 for the second, 3..
--for n-nacci sequences, this generates a sequence that converges to the square of the root
weird = weird' 0
  where weird' n (x:xs) = (xs !! n) - x:weird' (n+1) xs
